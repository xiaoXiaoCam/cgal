namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_KDOPTree
\cgalAutoToc
\author Xiao Xiao, Fehmi Cirak, Andreas Fabri

\section introduction Introduction

The KDOP_tree package offers a data structure and algorithms for efficient ray 
and distance queries on 3D triangular meshes using k-DOPs. The algorithms 
include intersection detection, intersection computation and distance 
computation. Currently all the intersection algorithms are available for ray 
queries, and the distance computation includes algorithms to compute the closest 
point on the primitives from the point query.

The K-DOP tree data structure is implemented based on the existing AABB tree data
structure, which takes an iterator range of geometric data as input and converts 
into primitives. A hierarchy of k-DOPs is constructed by first splitting the 
primitives in the same way as in AABB tree, i.e. a binary tree splitting along 
the longest axis, and then computing k-DOPs of each primitive and each node in 
a recursive bottom-top manner.

The main function interface is in class `KDOP_tree` which creates the k-DOP tree 
from an iterator range of geometric data. Once a k-DOP tree has been built, the 
algorithms for ray and distance queries can be applied. The interface functions 
share the same name with those defined in class `AABB_tree`.

\cgalFigureBegin{figkdop_bunny, bunny_aabb_kdop.png}
Left: Stanford Bunny mesh; Middle: AABB (6-DOP) of the bunny mesh; Right: 14-DOP of the bunny mesh
\cgalFigureEnd

\section definitions Definitions

A \b k-DOP is a bounding volume that is determined by a fixed \f$k\f$ (\f$k \geq 6\f$ 
in 3D) directions \f$\{\boldsymbol{d}_1, \cdots, \boldsymbol{d}_{k/2}, 
\boldsymbol{d}_{k/2 + 1}, \cdots, \boldsymbol{d}_k\}\f$. In the 
implementation, the first \f$k/2\f$  directions are given which should not be 
colinear between each other. For each  direction \f$\boldsymbol{d}_i (i = 1, \cdots, k/2)\f$, there 
is always an opposite direction \f$\boldsymbol{d}_{k/2 + i}\f$.

In each direction \f$\boldsymbol{d}_i\f$, a *support height* \f$h_i\f$ is computed as the 
maximum projected value of the primitive set on the direction, i.e.
\f$h_i = \max_j(\boldsymbol{x}_j \cdot \boldsymbol{d}_i)\f$ where 
\f$\boldsymbol{x}_j\f$ are coordinates of vertices in the set of primitives. In 
the implementation, a k-DOP is represented as \f$k\f$ support heights in \f$k\f$ 
directions. If unit directions (that is, the norm of the direction vector is 1) are 
considered to construct the k-DOP, each direction \f$\boldsymbol{d}_i\f$ together 
with its corresponding support height \f$h_i\f$ represent a half plane, and the 
\f$k\f$ half planes bound the object. Note that it is not necessary to take 
unit directions to construct the k-DOP for the query purposes.

An AABB can be seen as a 6-DOP with six unit directions in \f$\pm x\f$, \f$\pm y\f$ 
and \f$\pm z\f$  axes. Compared with the AABB, the k-DOP with \f$k > 6\f$ 
can provide a tighter bound for the object.

\section overlap_criteria Overlap criteria

\subsection criteria_kdop_kdop Overlap between a k-DOP and a k-DOP

For checking the overlap between two k-DOPs of mesh objects, it is 
straightforward to compare support heights (representing the k-DOPs) 
of the two objects in \f$k\f$ directions. As illustrated in Figure \cgalFigureRef{figkdop_overlap}, 
the triangle object and the hexagon object do not overlap in the 
direction \f$\boldsymbol{d}_i\f$, 
if

\f$h_i^T < -h_{k/2 + i}^H\f$, that is,
\f$h_i^T + h_{k/2 + i}^H < 0\f$.

The algorithm of overlap detection between two k-DOPs is implemented in the 
function `KDOP_kdop::do_overlap_kdop`.

\cgalFigureBegin{figkdop_overlap, kdop_overlap.png}
Overlap check between a triangle object and a hexagon object with support 
heights.
\cgalFigureEnd

\subsection criteria_kdop_ray Overlap between a k-DOP and a ray

For an efficient ray/k-DOP overlap detection, the intersections between 
the ray and parallel slabs (corresponding to opposite directions
\f$\boldsymbol{d}_i\f$ and \f$\boldsymbol{d}_{k/2 + i}\f$) are considered, as 
shown in Figure \cgalFigureRef{figkdop_ray}.

In each direction \f$\boldsymbol{d}_i\f$, there is a plane equation at the 
vertex where the support height \f$h_i\f$ is evaluated,
\f[
\boldsymbol{d}_i \cdot \boldsymbol{x} - h_i = 0 \, .
\f]

Substituting the ray equation \f$ \boldsymbol{r}(t) = (\boldsymbol{p} - \boldsymbol{s})t
 + \boldsymbol{s} \f$ into the plane equation yields,
 \f[
 t_i = \frac{h_i - \boldsymbol{d}_i\cdot\boldsymbol{s}}{\boldsymbol{d}_i\cdot\boldsymbol{p} - 
 \boldsymbol{d}_i\cdot\boldsymbol{s}}
 = \frac{h_i - h_i^s}{h_i^p - h_i^s} \, ,
 \f]
 where \f$h_i\f$ is the support height of the primitives in the direction 
 \f$\boldsymbol{d}_i\f$, \f$h_i^s\f$ and \f$h_i^p\f$ are the projected value of 
 the source point \f$\boldsymbol{s}\f$ and the second point \f$\boldsymbol{p}\f$ 
 of the ray on the direction  \f$\boldsymbol{d}_i\f$. There are two 
 intersection parameters \f$t\f$ between the ray and two parallel slabs in each 
 direction, and \f$t_i^{\min}\f$ and \f$t_i^{\max}\f$ depend on 
 the ray direction and the k-DOP direction (merely comparing \f$h_i^s\f$ and 
 \f$h_i^p\f$). Note that the special case \f$h_i^s = h_i^p\f$ (i.e. the ray is 
 parallel to the slabs) should be treated separately.
 
The ray and the k-DOP do not overlap if there exists a direction 
\f$\boldsymbol{d}_i\f$ whose intersection parameter range \f$[t_i^\min, t_i^\max]\f$ 
does not overlap with the range \f$[t_j^\min, t_j^\max]\f$ in any other direction 
\f$\boldsymbol{d}_j\f$. In the implementation, \f$t^\min\f$ is updated with the 
larger \f$t_j^\min\f$, and \f$t^\max\f$ is updated with the smaller \f$t_j^\max\f$. 
As long as \f$t^\min > t^\max\f$, the ray and the k-DOP are detected as not overlapping.
 
The algorithm of overlap detection between a ray and a k-DOP is implemented in 
the function `KDOP_kdop::do_overlap_ray`.

\cgalFigureBegin{figkdop_ray, ray_query.png}
Overlap detection between a ray and a k-DOP considering intersections with 
parallel slabs.
\cgalFigureEnd

\section kdop_examples Examples

\subsection example_ray_query Ray intersection

The following example shows the computation of first intersection between a ray 
and a triangular mesh. Some random points are read from a file. Rays are 
generated by shooting from every random point to the centroid of each triangle 
facet in the mesh. Without explicitly given, the directions of k-DOPs are derived according to the 
prescribed number of directions `NUM_DIRECTIONS`. For \f$k = 14\f$, the directions 
by default are \f$(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 1), (-1, 1, 1), (-1, -1, 1), (1, -1, 1)\f$ 
and their opposites (i.e. directions corresponding to axes and body diagonals).
\cgalExample{KDOP_tree/kdop_ray_query.cpp }


\subsection example_distance_query Closest point

In the following example the computation of closest points between random 
points and the triangular mesh is shown. The random points are read from 
a file.
\cgalExample{KDOP_tree/kdop_distance_query.cpp }


\subsection example_polytopes K-DOP visualisation

The following example shows how to visualise the k-DOPs, since the k-DOPs are 
represented as support heights in the implementation. In the k-DOP computation, 
the direction vectors are all converted to the ones with unit norms. In the 
example, we show how to define and set user-defined directions for k-DOPs instead 
of using default directions. The number of user-defined directions must be the 
same as `NUM_DIRECTIONS`.
\cgalExample{KDOP_tree/kdop_polytopes.cpp }


\section kdop_performance Performance

The performance of the k-DOP tree is demonstrated with an example of a gear with a skewed mesh 
as shown in Figure \cgalFigureRef{fig_kdop_gear}. The gear mesh contains 28,346 
vertices and 56,700 triangles. We consider two parameters as variables: the 
rotation angle \f$\alpha\f$ about \f$+x\f$ axis and the rotation angle 
\f$\beta\f$ about \f$+y\f$ axis. The influence of variations of the two variables 
(i.e. orientations of the gear) on the performance will be examined.

\cgalFigureBegin{fig_kdop_gear, gear.png}
Triangular surface mesh of a gear.
\cgalFigureEnd

\subsection build_time Build time

As \f$k\f$ increases, the build time for the k-DOP tree also increases slightly. Meanwhile,
the time for a 6-DOP is slightly more than the equivalent AABB. The reason for this is that 
the splitting process follows the AABB tree which also computes the bounding boxes of each 
node.

|         Schemes |   AABB | 6-DOP | 14-DOP | 18-DOP | 26-DOP |
| :-------------: | :----: | :---: | :----: | :----: | :----: |
|  Built time (s) | 0.0354 | 0.039 | 0.0426 | 0.0455 | 0.0493 |

\subsection tree_traversal Tree traversal

The k-DOP gives a tighter bound than AABB, and the bounding volume is tighter 
with a higher \f$k\f$. We take the gear mesh with \f$\alpha = \pi/4\f$ and 
\f$\beta = \pi/4\f$ as an example. The following table shows the number of nodes traversed 
and the number of primitives traversed in the tree to get all intersections 
with 1,134,000 rays. As it is indicated in the table, the number of nodes and 
primitives visited in the tree are reduced significantly as \f$k\f$ increases. 
The similar result can be observed considering other orientations of the gear 
mesh.

|         Schemes |   AABB | 6-DOP | 14-DOP | 18-DOP | 26-DOP |
| :--------------: | -----: | ----: | -----: | -----: | -----: |
|  No. of nodes traversed | 675,121,081 | 675,121,081 | 380,445,767 | 328,388,685 | 292,286,940 |
| No. of leaves traversed | 168,794,139 | 168,794,139 |  73,849,181 |  53,532,425 |  42,911,934 |


\subsection ray_query_time Ray query

The query time for ray intersections depends on the orientations of the mesh. 
We take the gear mesh with \f$\alpha = \pi/4\f$ and \f$\beta = \pi/4\f$ as an 
example.The following table compares the ray query time with AABB and different 
k-DOPs. As can be seen from the table, the ray query time reduces when using 
k-DOP with \f$k > 6\f$.

|         Functions |   AABB | 6-DOP | 14-DOP | 18-DOP | 26-DOP |
| :------------- | ----: | ---: | ----: | ----: | ----: |
| `KDOP_tree::do_intersect`| 5.5 | 4.596 | 4.14 | 4.44 | 5.128 |
| `KDOP_tree::any_intersection`| 5.156 | 4.428 | 4.128 | 4.276 | 5.052 |
| `KDOP_tree::first_intersection`| 11.576 | 11.708 | 9.152 | 8.836 | 9.916 |
| `KDOP_tree::all_intersections`| 25.472 | 22.656 | 19.664 | 19.348 | 21.908 |

To demonstrate the influence of orientations of the mesh on the query time, 
we consider seven different orientations and plot the query time of 
`KDOP_tree::do_intersect`. When the mesh is axis-aligned, i.e. \f$\alpha = 0\f$ 
and \f$\beta = 0\f$, 6-DOP takes the least query time, even compared with the 
equivalent AABB tree. The k-DOP (e.g. \f$k = 14\f$ and \f$k = 18\f$) tree takes 
less time when the mesh is not axis-aligned.

\cgalFigureBegin{fig_kdop_ray_query_gear, ray_query_gear.png}
'KDOP_tree::do_intersect' ray query time using different schemes for meshes in different orientations
\cgalFigureEnd

In addition, 26-DOP consumes more time than 14-DOP and 18-DOP in this example, and this is 
because the number of operations in the overlap check increases with a larger 
\f$k\f$ while the number of nodes and primitives traversed in the tree are reduced.
The trade-off between the increased number of operations proportional to \f$k\f$ 
and the reduced number of overlap checks can influence the performance of the 
k-DOP tree.

\subsection distance_query_time Distance Query

To compare the distance query time, we consider 100,000 random points and 
compute their closest points in the mesh, and different orientations of the 
mesh are also considered. The result is shown in Figure 
\cgalFigureRef{fig_kdop_distance_query_gear}. It can be observed that the k-DOP 
(\f$k > 6\f$) is faster than AABB tree when the mesh is not axis-aligned, and 
the 6-DOP is faster than the equivalent AABB tree.

\cgalFigureBegin{fig_kdop_distance_query_gear, distance_query_gear.png}
'KDOP_tree::closest_point' distance query time using different schemes for meshes in different orientations
\cgalFigureEnd

\subsection remark Remarks

In general, the k-DOP is more efficient than the AABB when there is a larger 
portion of skewed triangles in the mesh. However, it has to be mentioned that 
with tests on several isotropic meshes (e.g. the bunny mesh in Figure \cgalFigureRef{figkdop_bunny}), 
the k-DOP tree is not as efficient as the AABB tree structure for ray and 
distance queries. We think it is related to the trade-off between the increased 
number of operations in overlap checks and the reduced number of overlap checks.

\section ímplementation_history Implementation History

This package was developed by Xiao Xiao as a project of the Google Summer of Code 2019,
mentored by Fehmi Cirak and Andreas Fabri.
It is inspired from a version that was developed at the University of Cambridge by Xiao Xiao.

*/
} /* namespace CGAL */
